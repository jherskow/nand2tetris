##########################################################################
# FILE : CompilationEngineXML.py
# WRITER : Josuha Herskowitz , jherskow , 321658379
# WRITER : Aya Jbara , ayaj , 209048156
# EXERCISE : nand2tetris ex10 2017-2018
# DESCRIPTION:
##########################################################################
import char_dict as d
import SymbolTable
import VMWriter


class CompilationEngineXML:
    """
    Effects the actual compilation output.
    Gets its input from a VMWriter
    and emits its parsed structure into an output file/stream.
    The output is generated by a series of compilexxx() routines,
    one for every syntactic element xxx of the Jack grammar.
    The contract between these routines is
    that each compilexxx() routine should
        read the syntactic construct xxx from the input,
        advance() the tokenizer exactly beyond xxx ,
        and output the parsing of xxx .
    Thus, compilexxx() may only be called
    if indeed xxx is the next syntactic element of the input.
    """

    def __init__(self, tokenizer, output_file):
        """
        Creates a new compilation
        engine with the given input and
        output. The next routine called
        must be compileClass() .
        """
        self.output_file = output_file
        self.token = tokenizer
        self.vm_writer = VMWriter.VMWriter(output_file)
        self.symbol_table = None
        self.class_name = ""

        # get first token
        self.advance()

        if self.type() != d.KEYWORD or self.key_word() != d.K_CLASS:
            raise CompilerError(self, "File must begin with \"class\"")

        self.compile_class()

    def compile_class(self):
        """
        Compiles a complete class.
        """

        # todo == VM ==


        # class
        self.advance()

        # name

        if self.type() != d.IDENTIFIER:
            raise CompilerError(self, "Class must begin with class name")
        self.class_name = self.identifier()
        # todo == VM ==  create a new symbol_table  ( make helper function )

        self.symbol_table = self.make_symbol_table()  # todo == VM ==  class name?

        self.advance()

        self.compile_symbol_check("{", "Class must begin with {")

        self.compile_class_body()

    def compile_class_var_dec(self):
        """
        Compiles a static declaration or a field declaration.
        """

        # ( 'static' | 'field' ) type varName ( ',' varName)* ';'

        # static | field
        # todo == VM ==  declare class variable (make entry in symbol table with this info)
        # #    todo ===   static/field (counter) -> symbol table with name as key

        # static | field  (this is the kind)
        kind = self.get_kind()

        self.advance()

        # type
        # todo == VM == ....
        type = self.identifier()
        self.advance()

        # single varname
        name = self.identifier()  # todo == VM == ....
        self.advance()

        # todo get , kind and and type
        # todo and declare in sym table
        self.declare_variable(name, type, kind)
        self.write_push(name)

        # possible additional ',' varname  's
        while self.type() == d.SYMBOL and self.symbol() == ",":
            # skip the ','
            self.advance()

            # another varname
            name = self.identifier()  # todo == VM == ....
            self.advance()

            # declare under same kind and type
            self.declare_variable(name, type, kind)

            # push kind index
            self.write_push(name)

        # ;
        self.compile_symbol_check(";", "expected closing \";\" for declaration")

    def compile_subroutine(self):
        """
        Compiles a complete method, function, or constructor.
        """

        # ( 'constructor' | 'function' | 'method' )
        # ( 'void' | type) subroutineName '(' parameterList ')'
        # subroutineBody

        # 'constructor' | 'function' | 'method'
        # todo ==  if constrctor - specific stuff
        # todo ==  if method must push base adress first - then other arg
        # todo  == if functions - just push args and then call
        # locals number
        n_args = 0
        subroutine_type = self.key_word()
        self.advance()

        # 'void' | type
        # todo  ==  this goes to symbol table info about this func/method
        if self.type() == d.KEYWORD and self.key_word() == d.K_VOID:
            self.advance()
        else:
            self.compile_type()
        # todo === dow we need to determine the type of return val ??

        # subroutineName
        # todo needs to be changed to class.subroutineName
        # todo === dow we need to ude the name? ??
        name = self.identifier()
        self.advance()

        # (
        self.compile_symbol_check("(", "expected opening \"(\" for parameterList ")

        # parameterList 
        # todo == thi is the argument variables for the subroutine symbol table
        if subroutine_type == "method":
            # method (this,....)
            self.declare_variable("this", self.class_name, SymbolTable.ARG_KIND)
            # push this ARG_index
            self.write_push("this")
            n_args += 1
        n_args += self.compile_parameter_list()  # todo using declare_variable()

        # )
        self.compile_symbol_check(")", "expected closing \")\" for parameterList  ")

        self.write_function(name, n_args)

        # subroutineBody
        self.compile_subroutine_body()

    def compile_parameter_list(self):
        """
        compiles a (possibly empty) parameter list,
        not including the enclosing ()
        :return:
        """
        n_locals = 0
        # ( (type varName) ( ',' type varName)*)?

        # if empty - ?
        if self.type() == d.SYMBOL and self.symbol() == ")":
            return n_locals

        # otherwise first (type varname) must exist

        # single type varName
        # type
        type = self.key_word()  # todo OR IDENTIFIER
        self.advance()

        # var name
        name = self.identifier()
        self.advance()

        # declare
        self.declare_variable(name, type, SymbolTable.ARG_KIND)  # todo check ARG is correct

        # push kind index
        self.write_push(name)
        n_locals += 1

        # possible additional type varname  's
        while self.type() == d.SYMBOL and self.symbol() == ",":
            self.advance()

            # type
            type = self.key_word()  # todo OR IDENTIFIER
            self.advance()

            # var name
            name = self.identifier()
            self.advance()

            # declare
            self.declare_variable(name, type, SymbolTable.ARG_KIND)  # todo check ARG is correct

            # push kind index
            self.write_push(name)
            n_locals += 1

        return n_locals

    def compile_var_dec(self):
        """
        Compiles a var declaration.
        """

        # 'var' type varName ( ',' varName)* ';'

        # var
        if self.type() != d.KEYWORD and self.key_word() != d.K_VAR:
            raise CompilerError(self, "expected \"var\" in variable declaration")
        self.advance()

        # single type varName

        # type
        type = self.key_word()  # todo OR IDENTIFIER
        self.advance()

        # var name
        name = self.identifier()
        self.advance()

        # declare
        self.declare_variable(name, type, SymbolTable.VAR_KIND)  # todo check ARG is correct
        self.write_push(name)

        # possible additional "," varname  's
        while self.type() == d.SYMBOL and self.symbol() == ",":
            # skip the ","
            self.advance()

            # type
            type = self.key_word()  # todo OR IDENTIFIER or just token?// token
            self.advance()

            # var name
            name = self.identifier()
            self.advance()

            # declare
            self.declare_variable(name, type, SymbolTable.VAR_KIND)  # todo check ARG is correct
            self.write_push(name)

        # ';'
        self.compile_symbol_check(";", "expected ; at end of variable declaration")

    def compile_statements(self):
        """
        Compiles a sequence of statements,
        not including the enclosing {}.
        """
        #todooooooooooooooooooooooooooooooooooooo
        # todo == does this need anything?
        # statement*  0 or more times

        while self.type() == d.KEYWORD and self.key_word() in d.statement_types:
            statement_type = self.key_word()

            if statement_type == d.K_LET:
                self.compile_let()
            elif statement_type == d.K_IF:
                self.compile_if()
            elif statement_type == d.K_WHILE:
                self.compile_while()
            elif statement_type == d.K_DO:
                self.compile_do()
            elif statement_type == d.K_RETURN:
                self.compile_return()

    def compile_let(self):
        """
        Compiles a let statement.
        """

        # 'let' varName ( '[' expression ']' )? '=' expression ';'

        # let
        self.advance()

        # ==todo ====  save name (and index, if there is)
        # ==todo ====  compute where var[expression] is so we can pop to it
        # varname
        name = self.identifier()
        self.advance()

        # possible [ expression ] for array index
        if self.type() == d.SYMBOL and self.symbol() == "[":
            self.advance()
            self.compile_expression()
            self.compile_symbol_check("]", "expected to match [")

        # =
        self.compile_symbol_check("=", "expected in assignment")

        # expression
        # todo ====   then do all the stuff on the right
        self.compile_expression()

        # todo ====  finally, pop the value at top of stack (the result of the right)
        # todo ====  to VM location for name OR name[expression]

        # ;
        self.compile_symbol_check(";", "expected ; at end of assignment")

    def compile_do(self):
        """
        Compiles a do statement.
        """
        # todo == should be ok
        # 'do' subroutineCall ';'

        # do
        self.advance()

        # subroutineCall
        self.compile_subroutine_call()

        # ;
        self.compile_symbol_check(";", "expected ; after subroutine call")

    def compile_while(self):
        """
        Compiles a while statement.
        """

        # 'while' '(' expression ')' '{' statements '}'


        # while
        self.xml_keyword()
        self.advance()

        # '(' expression ')
        self.compile_symbol_check("(", "expected ( in (expression) for while")
        self.compile_expression()
        self.compile_symbol_check(")", "expected ) in (expression) for while")

        # '{' statements '}'
        self.compile_symbol_check("{", "expected { in {statements} for while")
        self.compile_statements()
        self.compile_symbol_check("}", "expected } in {statements} for while")


    def compile_return(self):
        """
        Compiles a return statement.
        """
        this = "returnStatement"
        self.xml_open(this)
        self.write("\n")

        # 'return' expression? ';'

        # return
        self.xml_keyword()
        self.advance()

        # expression?
        if not (self.type() == d.SYMBOL and self.symbol() == ";"):
            self.compile_expression()

        # ';'
        self.compile_symbol_check(";", "expected ; for return")

        self.xml_close(this)

    def compile_if(self):
        """
        Compiles a if statement,
        possibly with a trailing else clause.
        """
        this = "ifStatement"
        self.xml_open(this)
        self.write("\n")

        # 'if' '(' expression ')' '{' statements '}' ( 'else' '{' statements '}' )?

        self.xml_keyword()
        self.advance()

        # '(' expression ')'
        self.compile_symbol_check("(", "expected ( in (expression) for if")
        self.compile_expression()
        self.compile_symbol_check(")", "expected ) in (expression) for if")

        # '{' statements '}'
        self.compile_symbol_check("{", "expected { in {statements} for if")
        self.compile_statements()
        self.compile_symbol_check("}", "expected } in {statements} for if")

        # else
        if self.type() == d.KEYWORD and self.key_word() == d.K_ELSE:
            # else
            self.xml_keyword()
            self.advance()

            # '{' statements '}'
            self.compile_symbol_check("{", "expected { in {statements} for else")
            self.compile_statements()
            self.compile_symbol_check("}", "expected } in {statements} for else")

        self.xml_close(this)

    def compile_expression(self):
        """
        Compiles a expression.
        """
        # todo == what does this do?
        # todo ==     ? probbly leave the final value on the stack ?

        # term (op term)*

        # term
        self.compile_term()

        # (op term)*  0 or more times
        while self.type() == d.SYMBOL and self.symbol() in d.op:
            self.compile_op()
            self.compile_term()

    def compile_term(self):
        """
        Compiles a term.
        This routine is faced with a slight difficulty
        when trying to decide between some of the alternative parsing rules.
        Specifically, if the current token is an identifier,
        the routine must distinguish between
         a variable,
         an array entry,
         and a subroutine call.
        A single look- ahead token,
        which may be one of [, (, or .
        suffices to distinguish between the three possibilities.
        Any other token is not part of this term
        and should not be advanced over.
        """

        first_type = self.type()

        if first_type == d.INT_CONST:
            self.compile_int_const()

        elif first_type == d.STRING_CONST:
            self.compile_str_const()

        elif first_type == d.KEYWORD:
            if self.key_word() in d.keyword_constant:
                self.compile_keyword_const()

        elif first_type == d.IDENTIFIER:
            # could be varname, varname[expression], subroutine call ( "(" )
            self.advance()
            if self.type() == d.SYMBOL:

                if self.symbol() == "[":
                    # varname[expression]
                    self.retreat()

                    # varname
                    self.compile_var_name()

                    # [
                    self.compile_symbol_check("[", "[ expected for array index")

                    #  expression
                    self.compile_expression()

                    # [
                    self.compile_symbol_check("]", "] expected for array index")

                elif self.symbol() in {"(", "."}:
                    self.retreat()
                    self.compile_subroutine_call()

                else:
                    self.retreat()
                    self.xml_identifier()
                    self.advance()

            else:
                self.retreat()
                self.xml_identifier()
                self.advance()

        elif first_type == d.SYMBOL and self.symbol() == "(":
            # (expression)

            # (
            self.xml_symbol()
            self.advance()

            # expression
            self.compile_expression()

            # )
            self.compile_symbol_check(")", "expression should end with ) ")

        elif first_type == d.SYMBOL and self.symbol() in d.unary_op:
            # unOp term
            self.xml_symbol()
            self.advance()

            self.compile_term()

        else:
            raise CompilerError(self, "invalid term")

    def compile_expression_list(self):
        """
        Compiles a (possibly empty) comma-separated list of expressions.
        """
        this = "expressionList"
        self.xml_open(this)
        self.write("\n")

        # (expression ( ',' expression)* )?
        # nothing, an expression, or many

        # empty
        if self.type() == d.SYMBOL and self.symbol() == ")":
            self.xml_close(this)
            return

        # one expression
        self.compile_expression()

        # possible additional expressions  's
        while self.type() == d.SYMBOL and self.symbol() == ",":
            self.xml_symbol()
            self.advance()
            self.compile_expression()

        self.xml_close(this)

    # sub compiler functions __________________________

    def compile_class_body(self):
        """
        Complies the body of a class
        """
        # we are now at first line in class

        # while next toks match classVarDec, compile class var dec
        while self.type() == d.KEYWORD and self.key_word() in d.static_field:
            #  static or field)
            self.compile_class_var_dec()

        # while next toks match subroutineDec, compile subroutineDec
        while self.type() == d.KEYWORD and self.key_word() in d.func:
            self.compile_subroutine()

        # ensure next token is }
        self.compile_symbol_check("}", "Class must contain only variable declarations and then subroutine declarations")

    def compile_type(self):
        """
        Compiles a type
        :return:
        """
        if self.type() == d.KEYWORD and self.key_word() in d.type:
            self.xml_keyword()
        elif self.type() == d.IDENTIFIER:
            self.xml_identifier()
        else:
            raise CompilerError(self, "type expected")
        self.advance()

    def compile_var_name(self):
        """
        write a variable name
        """
        #
        self.advance()

    def compile_symbol_check(self, symbol, message):
        if self.type() != d.SYMBOL or self.symbol() != symbol:
            raise CompilerError(self, message)
        self.advance()

    def compile_subroutine_call(self):
        """
        """
        # subroutineName '(' expressionList ')' | (className |varName) '.' subroutineName '(' expressionList ')'
        # possibilities are
        # func(list)
        # class.func(list)
        # var.func(list)


        # TODO == todo subroutine call

        # look forward
        self.advance()
        # todo - if no "." - foo() - we want to call foo in curerent class
        # todo - if foo is method - we must also send 'this'

        if self.type() == d.SYMBOL and self.symbol() == "(":
            # subroutineName '(' expressionList ')'
            self.retreat()

            # subroutineName
            self.advance()

            # (
            self.compile_symbol_check("(", "expected ( for function arguments")

            # expressionList
            self.compile_expression_list()

            # )
            self.compile_symbol_check(")", "expected ) for function arguments")
        # todo - if no "." - then this is class.foo or object.foo
        elif self.type() == d.SYMBOL and self.symbol() == ".":
            # (className |varName) '.' subroutineName '(' expressionList ')'
            self.retreat()

            # (className |varName)
            self.xml_identifier()
            self.advance()

            # '.'
            self.compile_symbol_check(".", "expected . for class.method")

            # subroutineName
            self.xml_identifier()
            self.advance()

            # '('
            self.compile_symbol_check("(", "expected ( for function arguments")

            # expressionList
            self.compile_expression_list()

            # )
            self.compile_symbol_check(")", "expected ) for function arguments")

        else:
            raise CompilerError(self, "Expected func(list) or class.func(list)")

    def compile_subroutine_name(self):
        """
        Complies a subroutine name
        """
        self.xml_identifier()
        self.advance()

    def compile_subroutine_body(self):
        """
        :return:
        """
        # '{' varDec* statements '}'

        # '{'
        self.compile_symbol_check("{", "Expected { to open method body")

        #  varDec*
        while self.type() == d.KEYWORD and self.key_word() == d.K_VAR:
            self.compile_var_dec()

        # statements
        self.compile_statements()

        # '}'
        self.compile_symbol_check("}", "Expected } to close method body")

    def compile_op(self):
        """
        compiles an operator
        """
        self.xml_symbol()
        self.advance()

    def compile_int_const(self):
        self.xml_open("integerConstant")
        self.write(str(self.int_val()))
        self.xml_close("integerConstant")
        self.advance()

    def compile_str_const(self):
        self.xml_open("stringConstant")
        self.write_string_constant(self.string_val())
        self.xml_close("stringConstant")
        self.advance()

    def compile_keyword_const(self):
        self.xml_keyword()
        self.advance()

    # todo VM HELPER FUNCTIONS=========================
    def make_symbol_table(self):
        """make a new sybol table"""
        self.symbol_table = SymbolTable.SymbolTable()

    def declare_variable(self, name, type, kind):
        """make a new sybol table"""
        self.symbol_table.define(name, type, kind)

    def get_kind(self):
        """ returns kind of the identifier (VAR, ARD, FIELD, STATIC)"""
        kind = self.key_word()
        if kind == "var":
            return SymbolTable.VAR_KIND
        elif kind == "static":
            return SymbolTable.STATIC_KIND
        elif kind == "field":
            return SymbolTable.STATIC_KIND
        else:
            return SymbolTable.ARG_KIND

    def write_push(self, name):
        self.vm_writer.write_push(self.symbol_table.kind_of(name),
                                  self.symbol_table.index_od(name))

    def write_pop(self, name):
        self.vm_writer.write_pop(self.symbol_table.kind_of(name),
                                 self.symbol_table.index_od(name))

    def write_function(self, name, n_locals):
        method_name = self.class_name + "." + name
        self.vm_writer.write_function(method_name, n_locals)



    # todo VM HELPER FUNCTIONS=========================


    # HELPER FUNCTIONS __________________________




    def write(self, string):
        """
        writes a string to output file
        """
        self.output_file.write(string)

    def write_string_constant(self, string):
        """
        writes a string litral to xml
        """
        lst = list(string)
        new_str = ""
        for char in lst:
            if char in d.symbol_switch:
                new_str += d.symbol_switch[char]
            else:
                new_str += char
        self.write(new_str)

    def xml_open(self, string):
        """
        writes <string> to output file
        """
        self.write("<" + string + ">")

    def xml_close(self, string):
        """
        writes <string> to output file
        """
        self.write("</" + string + ">\n")

    def xml_keyword(self):
        """
        writes a keyword to output file
        """
        self.xml_open("keyword")
        self.write(d.keyword_switch[self.key_word()])
        self.xml_close("keyword")

    def xml_identifier(self):
        """
        writes a identifier to output file
        """
        self.xml_open("identifier")
        self.write(self.identifier())
        self.xml_close("identifier")

    def xml_symbol(self):
        """
        writes a symbol to output file
        """
        self.xml_open("symbol")
        self.write(d.symbol_switch[self.symbol()])
        self.xml_close("symbol")

    def advance(self):
        self.token.advance()

    def retreat(self):
        self.token.go_back()

    def line_num(self):
        return self.token.get_cur_line()

    def type(self):
        return self.token.token_type()

    def key_word(self):
        return self.token.key_word()

    def symbol(self):
        return self.token.symbol()

    def identifier(self):
        return self.token.identifier()

    def int_val(self):
        return self.token.int_val()

    def string_val(self):
        return self.token.string_val()


class CompilerError(SyntaxError):
    def __init__(self, engine, message=""):
        self.msg = "error in file\n" + engine.output_file.name + \
                   "\nerror in line " + str(engine.line_num()) + "\n" + \
                   message + "\n"
